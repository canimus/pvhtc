{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Hello \ud83d\udc4b, thanks for taking the time to review this technical challenge. This documentation micro-site, encloses the brief technical elements used to complete the technical challenge. Tasks The task is to create an automated E2E test suite for the following public website: https://nl.tommy.com/ The tests should cover the following functionality: Create a new user account. Browser support: Google Chrome The test suite should support desktop and mobile versions of the website. For mobile tests please use Chrome mobile emulation. Accomplished Automated Suite Create a new user account Browser support Google Chrome Desktop website Mobile Website Scenarios Account creation Email confirmation with new account Image entropy validation for current website (Guarantee for color and styles) Object Character Recognition (OCR) on images Verify errors during registration process New address Comments I put focus in creating the main scenario for account creation using external valid emails, and based on the conversation about the current challenges of the team regarding the validation of styles, or the use of machine learning in different areas of the test automation scope.","title":"Home"},{"location":"#home","text":"Hello \ud83d\udc4b, thanks for taking the time to review this technical challenge. This documentation micro-site, encloses the brief technical elements used to complete the technical challenge.","title":"Home"},{"location":"#tasks","text":"The task is to create an automated E2E test suite for the following public website: https://nl.tommy.com/ The tests should cover the following functionality: Create a new user account. Browser support: Google Chrome The test suite should support desktop and mobile versions of the website. For mobile tests please use Chrome mobile emulation.","title":"Tasks"},{"location":"#accomplished","text":"Automated Suite Create a new user account Browser support Google Chrome Desktop website Mobile Website","title":"Accomplished"},{"location":"#scenarios","text":"Account creation Email confirmation with new account Image entropy validation for current website (Guarantee for color and styles) Object Character Recognition (OCR) on images Verify errors during registration process New address","title":"Scenarios"},{"location":"#comments","text":"I put focus in creating the main scenario for account creation using external valid emails, and based on the conversation about the current challenges of the team regarding the validation of styles, or the use of machine learning in different areas of the test automation scope.","title":"Comments"},{"location":"results/","text":"Results In this section we will navigate through the accomplishments of the automated test script. Snapshoots 1 Opening Browser 2 Pointing to Logo 3 Accepting Cookies 4 Closing Shipping Panel 5 Open Registration Panel 6 Enter Email 7 Enter Password 8 Enter Password Confirmation 9 Accept Terms and Conditions 10 Click Registration OK Verify Email Received","title":"Results"},{"location":"results/#results","text":"In this section we will navigate through the accomplishments of the automated test script. Snapshoots 1","title":"Results"},{"location":"results/#opening-browser","text":"2","title":"Opening Browser"},{"location":"results/#pointing-to-logo","text":"3","title":"Pointing to Logo"},{"location":"results/#accepting-cookies","text":"4","title":"Accepting Cookies"},{"location":"results/#closing-shipping-panel","text":"5","title":"Closing Shipping Panel"},{"location":"results/#open-registration-panel","text":"6","title":"Open Registration Panel"},{"location":"results/#enter-email","text":"7","title":"Enter Email"},{"location":"results/#enter-password","text":"8","title":"Enter Password"},{"location":"results/#enter-password-confirmation","text":"9","title":"Enter Password Confirmation"},{"location":"results/#accept-terms-and-conditions","text":"10","title":"Accept Terms and Conditions"},{"location":"results/#click-registration","text":"OK","title":"Click Registration"},{"location":"results/#verify-email-received","text":"","title":"Verify Email Received"},{"location":"run/","text":"Run Considering that you successfully build the container, as explained in the previous section, the next step consists in simply running the container. The only requirement for the container is to map an external volume from the host, where the test script is located, as explained in the command below: # Execution with needed volume docker run -it --rm -v $PWD /src:/scripts pvhtcpy Steps The following section describes the code that covers the main test scenario. The 4 steps described, enclose the test steps of the scenario of the challenge. Test Scenario s1: Email This step visits a website that produces valid email addresses and is able to capture received emails to that account. driver = webdriver . Chrome ( options = set_chrome_options ()) driver . get ( \"https://emailfake.com/\" ) print ( 'EmailGenerator:' + driver . title ) # Email is imaged as a pair of inputs inputs = driver . find_elements_by_tag_name ( \"input\" ) ocr = { 'email' : 0 , 'domain' : 2 } list ( map ( lambda x : mc ( \"screenshot\" , f '/scripts/ { x [ 0 ] } .png' )( inputs [ x [ 1 ]]), ocr . items ())) email , domain = [ pytesseract . image_to_string ( Image . open ( f '/scripts/ { i } .png' )) . strip () for i in ocr . keys ()] print ( f 'Email:[ { email } ] Check=> { len ( email ) > 0 } ' ) print ( f 'Domain:[ { domain } ] Check=> { len ( domain ) > 0 } ' ) if len ( email ) > 0 and len ( domain ) > 0 : print ( chalk . cyan ( \"Email Ok\" )) else : print ( chalk . red ( \"Sorry, my eyes are tired and couldn't parse your email\" )) sys . exit () # Induced garbage caracter in domain by image if (( not domain [ 0 ] . isalnum ()) or ( domain [ 0 ] . isupper ())): domain = domain [ 1 :] email_address = f ' { email } @ { domain } ' print ( chalk . magenta ( email_address , bold = True )) Output : EmailGenerator:Fake Email Generator - temp mail address Email:[gastroga] Check=>True Domain:[lotomoneymaker.com] Check=>True Email Ok gastroga@lotomoneymaker.com s2: Website In this step we navigate to the Tommy Hilfiger website, and validate that the pictures match the captured entropy during authoring the script. # With an account lets try to register driver2 = webdriver . Chrome ( options = set_chrome_options ()) driver2 . maximize_window () driver2 . get ( \"https://nl.tommy.com/\" ) driver2 . get_screenshot_as_file ( '/scripts/tommy_0.png' ) screen_0 = Image . open ( \"/scripts/tommy_0.png\" ) assert np . isclose ( screen_0 . entropy (), 7 , rtol =. 15 ) print ( \"Entropy Close Verification\" ) print ( \"WebSite: \" + driver2 . title ) assert \"Tommy Hilfiger\" in driver2 . title Output: Entropy Close Verification WebSite: Tommy Hilfiger\u00ae Nederland | Offici\u00eble Online Winkel s3: Fill Form I made use of two types of selectors: xpath and css . I personally think that the use of xpath is more convinient in most of the cases. In addition to the fill up of the form, additional tasks were completed like: Agreeing to the cookie policy of the website Closing the banner display on top of the page, offering free delivery # s3.1 Neutralize Pointer in Screen tommy_logo = driver2 . find_element_by_xpath ( \"//a[@title='Tommy Hilfiger']\" ) ac = ActionChains ( driver2 ) if tommy_logo : print ( 'Pointer at Page Logo' ) ac . move_to_element ( tommy_logo ) driver2 . get_screenshot_as_file ( f '/scripts/tommy_1.png' ) # s3.2 Accept Cookie Policy accept_cookies_banner = driver2 . find_element_by_xpath ( \"//div[@class='cookie-notice__action']/button[1]\" ) if accept_cookies_banner : print ( 'Cookies Agreement Banner' ) accept_cookies_banner . click () driver2 . get_screenshot_as_file ( f '/scripts/tommy_2.png' ) # s3.3 Close Shipping Banner free_shipping_banner = driver2 . find_element_by_xpath ( \"//button[@class='slide__background--close']\" ) if free_shipping_banner : print ( \"Shipping Free Banner\" ) free_shipping_banner . click () driver2 . get_screenshot_as_file ( f '/scripts/tommy_3.png' ) # s3.4 Open Registration Panel registration_button = driver2 . find_element_by_xpath ( \"//button[@class='header__link']\" ) if registration_button : print ( \"Opening Registration Panel\" ) registration_button . click () WebDriverWait ( driver2 , 2 ) . until ( EC . visibility_of_element_located (( By . XPATH , \"//input[@type='email' and @name='email1']\" ))) driver2 . get_screenshot_as_file ( f '/scripts/tommy_4.png' ) # s3.5 Enter Email field email_field = driver2 . find_element_by_xpath ( \"//input[@type='email' and @name='email1']\" ) if email_field : print ( \"Entering Email\" ) email_field . send_keys ( email_address ) driver2 . get_screenshot_as_file ( f '/scripts/tommy_5.png' ) # s3.6 Enter Password field password_field = driver2 . find_element_by_xpath ( \"//div[@class='register__passwords']//input[@type='password' and @name='logonPassword']\" ) if password_field : print ( \"Entering Password\" ) password_field . send_keys ( \"TommyChallenge2020\" ) driver2 . get_screenshot_as_file ( f '/scripts/tommy_6.png' ) # s3.7 Enter Password Confirmation password_confirmation_field = driver2 . find_element_by_xpath ( \"//div[@class='register__passwords']//input[@type='password' and @name='logonPasswordVerify']\" ) if password_confirmation_field : print ( \"Confirmation Password\" ) password_confirmation_field . send_keys ( \"TommyChallenge2020\" ) driver2 . get_screenshot_as_file ( f '/scripts/tommy_7.png' ) # s3.8 Accept Terms and Conditions accept_terms = driver2 . find_element_by_xpath ( \"//label[@for='signUpForTermsCondition1']\" ) if accept_terms : print ( \"Accept Terms and Conditions\" ) accept_terms . click () driver2 . get_screenshot_as_file ( f '/scripts/tommy_8.png' ) # 3.9 Click Registration Button button_registration = driver2 . find_element_by_xpath ( \"//button[contains(text(), 'Registreren') and @type='submit']\" ) if button_registration : print ( \"Complete Registration\" ) button_registration . click () WebDriverWait ( driver2 , timeout = 10 , poll_frequency = 2 ) . until ( EC . title_contains ( 'Mijn account' )) driver2 . get_screenshot_as_file ( f '/scripts/tommy_9.png' ) Output: Pointer at Page Logo Cookies Agreement Banner Shipping Free Banner Opening Registration Panel Entering Email Entering Password Confirmation Password Accept Terms and Conditions Complete Registration s4: Confirmation An email message is sent to the external website, and displayed in an internal panel. The information is displayed and captured in each of the snapshots captured during navigation. # TODO: Address the wait with Expected Condition. Left on purpose time . sleep ( EMAIL_WAIT_THRESHOLD ) print ( chalk . yellow ( \"New Mail!\" )) # TODO: Actions.movo_to element but this also works email_body = driver . find_element_by_tag_name ( 'body' ) email_body . send_keys ( Keys . PAGE_DOWN ) email_body . send_keys ( Keys . PAGE_DOWN ) driver . get_screenshot_as_file ( f '/scripts/tommy_10.png' ) print ( chalk . green ( \"OK\" )) driver . quit () Output: New Mail! OK This section covered the execution details, the next section details the accomplishments of the technical challenge.","title":"Run"},{"location":"run/#run","text":"Considering that you successfully build the container, as explained in the previous section, the next step consists in simply running the container. The only requirement for the container is to map an external volume from the host, where the test script is located, as explained in the command below: # Execution with needed volume docker run -it --rm -v $PWD /src:/scripts pvhtcpy","title":"Run"},{"location":"run/#steps","text":"The following section describes the code that covers the main test scenario. The 4 steps described, enclose the test steps of the scenario of the challenge. Test Scenario s1: Email This step visits a website that produces valid email addresses and is able to capture received emails to that account. driver = webdriver . Chrome ( options = set_chrome_options ()) driver . get ( \"https://emailfake.com/\" ) print ( 'EmailGenerator:' + driver . title ) # Email is imaged as a pair of inputs inputs = driver . find_elements_by_tag_name ( \"input\" ) ocr = { 'email' : 0 , 'domain' : 2 } list ( map ( lambda x : mc ( \"screenshot\" , f '/scripts/ { x [ 0 ] } .png' )( inputs [ x [ 1 ]]), ocr . items ())) email , domain = [ pytesseract . image_to_string ( Image . open ( f '/scripts/ { i } .png' )) . strip () for i in ocr . keys ()] print ( f 'Email:[ { email } ] Check=> { len ( email ) > 0 } ' ) print ( f 'Domain:[ { domain } ] Check=> { len ( domain ) > 0 } ' ) if len ( email ) > 0 and len ( domain ) > 0 : print ( chalk . cyan ( \"Email Ok\" )) else : print ( chalk . red ( \"Sorry, my eyes are tired and couldn't parse your email\" )) sys . exit () # Induced garbage caracter in domain by image if (( not domain [ 0 ] . isalnum ()) or ( domain [ 0 ] . isupper ())): domain = domain [ 1 :] email_address = f ' { email } @ { domain } ' print ( chalk . magenta ( email_address , bold = True )) Output : EmailGenerator:Fake Email Generator - temp mail address Email:[gastroga] Check=>True Domain:[lotomoneymaker.com] Check=>True Email Ok gastroga@lotomoneymaker.com s2: Website In this step we navigate to the Tommy Hilfiger website, and validate that the pictures match the captured entropy during authoring the script. # With an account lets try to register driver2 = webdriver . Chrome ( options = set_chrome_options ()) driver2 . maximize_window () driver2 . get ( \"https://nl.tommy.com/\" ) driver2 . get_screenshot_as_file ( '/scripts/tommy_0.png' ) screen_0 = Image . open ( \"/scripts/tommy_0.png\" ) assert np . isclose ( screen_0 . entropy (), 7 , rtol =. 15 ) print ( \"Entropy Close Verification\" ) print ( \"WebSite: \" + driver2 . title ) assert \"Tommy Hilfiger\" in driver2 . title Output: Entropy Close Verification WebSite: Tommy Hilfiger\u00ae Nederland | Offici\u00eble Online Winkel s3: Fill Form I made use of two types of selectors: xpath and css . I personally think that the use of xpath is more convinient in most of the cases. In addition to the fill up of the form, additional tasks were completed like: Agreeing to the cookie policy of the website Closing the banner display on top of the page, offering free delivery # s3.1 Neutralize Pointer in Screen tommy_logo = driver2 . find_element_by_xpath ( \"//a[@title='Tommy Hilfiger']\" ) ac = ActionChains ( driver2 ) if tommy_logo : print ( 'Pointer at Page Logo' ) ac . move_to_element ( tommy_logo ) driver2 . get_screenshot_as_file ( f '/scripts/tommy_1.png' ) # s3.2 Accept Cookie Policy accept_cookies_banner = driver2 . find_element_by_xpath ( \"//div[@class='cookie-notice__action']/button[1]\" ) if accept_cookies_banner : print ( 'Cookies Agreement Banner' ) accept_cookies_banner . click () driver2 . get_screenshot_as_file ( f '/scripts/tommy_2.png' ) # s3.3 Close Shipping Banner free_shipping_banner = driver2 . find_element_by_xpath ( \"//button[@class='slide__background--close']\" ) if free_shipping_banner : print ( \"Shipping Free Banner\" ) free_shipping_banner . click () driver2 . get_screenshot_as_file ( f '/scripts/tommy_3.png' ) # s3.4 Open Registration Panel registration_button = driver2 . find_element_by_xpath ( \"//button[@class='header__link']\" ) if registration_button : print ( \"Opening Registration Panel\" ) registration_button . click () WebDriverWait ( driver2 , 2 ) . until ( EC . visibility_of_element_located (( By . XPATH , \"//input[@type='email' and @name='email1']\" ))) driver2 . get_screenshot_as_file ( f '/scripts/tommy_4.png' ) # s3.5 Enter Email field email_field = driver2 . find_element_by_xpath ( \"//input[@type='email' and @name='email1']\" ) if email_field : print ( \"Entering Email\" ) email_field . send_keys ( email_address ) driver2 . get_screenshot_as_file ( f '/scripts/tommy_5.png' ) # s3.6 Enter Password field password_field = driver2 . find_element_by_xpath ( \"//div[@class='register__passwords']//input[@type='password' and @name='logonPassword']\" ) if password_field : print ( \"Entering Password\" ) password_field . send_keys ( \"TommyChallenge2020\" ) driver2 . get_screenshot_as_file ( f '/scripts/tommy_6.png' ) # s3.7 Enter Password Confirmation password_confirmation_field = driver2 . find_element_by_xpath ( \"//div[@class='register__passwords']//input[@type='password' and @name='logonPasswordVerify']\" ) if password_confirmation_field : print ( \"Confirmation Password\" ) password_confirmation_field . send_keys ( \"TommyChallenge2020\" ) driver2 . get_screenshot_as_file ( f '/scripts/tommy_7.png' ) # s3.8 Accept Terms and Conditions accept_terms = driver2 . find_element_by_xpath ( \"//label[@for='signUpForTermsCondition1']\" ) if accept_terms : print ( \"Accept Terms and Conditions\" ) accept_terms . click () driver2 . get_screenshot_as_file ( f '/scripts/tommy_8.png' ) # 3.9 Click Registration Button button_registration = driver2 . find_element_by_xpath ( \"//button[contains(text(), 'Registreren') and @type='submit']\" ) if button_registration : print ( \"Complete Registration\" ) button_registration . click () WebDriverWait ( driver2 , timeout = 10 , poll_frequency = 2 ) . until ( EC . title_contains ( 'Mijn account' )) driver2 . get_screenshot_as_file ( f '/scripts/tommy_9.png' ) Output: Pointer at Page Logo Cookies Agreement Banner Shipping Free Banner Opening Registration Panel Entering Email Entering Password Confirmation Password Accept Terms and Conditions Complete Registration s4: Confirmation An email message is sent to the external website, and displayed in an internal panel. The information is displayed and captured in each of the snapshots captured during navigation. # TODO: Address the wait with Expected Condition. Left on purpose time . sleep ( EMAIL_WAIT_THRESHOLD ) print ( chalk . yellow ( \"New Mail!\" )) # TODO: Actions.movo_to element but this also works email_body = driver . find_element_by_tag_name ( 'body' ) email_body . send_keys ( Keys . PAGE_DOWN ) email_body . send_keys ( Keys . PAGE_DOWN ) driver . get_screenshot_as_file ( f '/scripts/tommy_10.png' ) print ( chalk . green ( \"OK\" )) driver . quit () Output: New Mail! OK This section covered the execution details, the next section details the accomplishments of the technical challenge.","title":"Steps"},{"location":"setup/","text":"Setup This project requires you to build a container, you can use the technology of your choice docker or podman the image is tested using both technologies. Why Python? The language of choice for the technical challenge was python specially because of my familiarity with the language. However I explore the use of typescript when beggining the technical challenge, but due to time constraints, I decided to implement the rest of the project in a language that didn't require compilation. Building a container is out of the scope of this technical challenge, and one of the assumptions is that your computer, has any of the technologies mentioned before, docker or buildah to accomplish the preparation task. Cloning Repo First step is to download the code from the repository git clone https://github.com/canimus/pvhtc # move to directory cd pvhtc Build Container The only requirement for the build is to execute the following command # Building the PVH technical challenge image docker build --rm . -t pvhtcpy Container Details At this point, you can continue reading the details about the container image, or you can just jump to the execution of the test suite, in the next section. Run Container File The different sections of the container file are explained below: Base Image # python 3.8 installed FROM python:3.8 For a production environment an alpine image is recommended as it will consume less space. Also because it could be deployed faster. In the case of the technical challenge, speed and operational readiness were not the considerations for the completion, and therefore I chose for an image that could get the job done quick, and without the need of additional setup from the operative system level. OCR Libs For reading characters from images, I used the tesseract library. With its binging to python in the library pytesseract # Installing OS Libraries RUN apt-get install -yqq unzip zstd tesseract-ocr libtesseract-dev Chrome Browser As per the specification the only web browser under the scope is Chrome, hereby we setup the repositories to download the software binaries. # Google Repos RUN wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add - # Chrome RUN sh -c 'echo \"deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main\" >> /etc/apt/sources.list.d/google-chrome.list' # Latest Versions RUN apt-get -y update # Browser Install RUN apt-get install -y google-chrome-stable Chrome Driver In order to enable the webdriver integration with the web browser, it is required to install the web driver libraries. Incorporated in the settings below. # Download the Chrome Driver RUN wget -O /tmp/chromedriver.zip http://chromedriver.storage.googleapis.com/ ` curl -sS chromedriver.storage.googleapis.com/LATEST_RELEASE ` /chromedriver_linux64.zip # Unzip the Chrome Driver into /usr/local/bin directory RUN unzip /tmp/chromedriver.zip chromedriver -d /usr/local/bin/ # Set display port as an environment variable ENV DISPLAY = :99 Python Libs The execution requires selenium as the main library to conduct the automation routines and additional libraries for the additional features covered by this automated test script. WORKDIR /usr/src COPY requirements.txt . RUN pip install --upgrade pip RUN pip install -r requirements.txt requirements.txt selenium == 3.141 . 0 pytesseract == 0.3 . 6 Pillow == 8.0 . 1 numpy == 1.19 . 4 Faker == 4.14 . 2 fake - useragent == 0.1 . 11 pychalk == 2.0 . 1 mkdocs - material == 6.1 . 5 behave == 1.2 . 6 Runtime The container uses a volume at the root of the file system, to pass scripts to be executed inside of the container in the path /scripts . It is expected that when running the container a volume from the external host system, is mapped to this volume for execution. The expected default script for running the suite is main.py . # Location of Automated Test Scripts VOLUME /scripts CMD [ \"python\" , \"/scripts/main.py\" ] Now we are ready to run the container and with it, the automated test script that covers the technical challenge. Please go ahead to the Run section by navigating in the footer of this page...","title":"Setup"},{"location":"setup/#setup","text":"This project requires you to build a container, you can use the technology of your choice docker or podman the image is tested using both technologies. Why Python? The language of choice for the technical challenge was python specially because of my familiarity with the language. However I explore the use of typescript when beggining the technical challenge, but due to time constraints, I decided to implement the rest of the project in a language that didn't require compilation. Building a container is out of the scope of this technical challenge, and one of the assumptions is that your computer, has any of the technologies mentioned before, docker or buildah to accomplish the preparation task.","title":"Setup"},{"location":"setup/#cloning-repo","text":"First step is to download the code from the repository git clone https://github.com/canimus/pvhtc # move to directory cd pvhtc","title":"Cloning Repo"},{"location":"setup/#build-container","text":"The only requirement for the build is to execute the following command # Building the PVH technical challenge image docker build --rm . -t pvhtcpy Container Details At this point, you can continue reading the details about the container image, or you can just jump to the execution of the test suite, in the next section. Run","title":"Build Container"},{"location":"setup/#container-file","text":"The different sections of the container file are explained below:","title":"Container File"},{"location":"setup/#base-image","text":"# python 3.8 installed FROM python:3.8 For a production environment an alpine image is recommended as it will consume less space. Also because it could be deployed faster. In the case of the technical challenge, speed and operational readiness were not the considerations for the completion, and therefore I chose for an image that could get the job done quick, and without the need of additional setup from the operative system level.","title":"Base Image"},{"location":"setup/#ocr-libs","text":"For reading characters from images, I used the tesseract library. With its binging to python in the library pytesseract # Installing OS Libraries RUN apt-get install -yqq unzip zstd tesseract-ocr libtesseract-dev","title":"OCR Libs"},{"location":"setup/#chrome-browser","text":"As per the specification the only web browser under the scope is Chrome, hereby we setup the repositories to download the software binaries. # Google Repos RUN wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add - # Chrome RUN sh -c 'echo \"deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main\" >> /etc/apt/sources.list.d/google-chrome.list' # Latest Versions RUN apt-get -y update # Browser Install RUN apt-get install -y google-chrome-stable","title":"Chrome Browser"},{"location":"setup/#chrome-driver","text":"In order to enable the webdriver integration with the web browser, it is required to install the web driver libraries. Incorporated in the settings below. # Download the Chrome Driver RUN wget -O /tmp/chromedriver.zip http://chromedriver.storage.googleapis.com/ ` curl -sS chromedriver.storage.googleapis.com/LATEST_RELEASE ` /chromedriver_linux64.zip # Unzip the Chrome Driver into /usr/local/bin directory RUN unzip /tmp/chromedriver.zip chromedriver -d /usr/local/bin/ # Set display port as an environment variable ENV DISPLAY = :99","title":"Chrome Driver"},{"location":"setup/#python-libs","text":"The execution requires selenium as the main library to conduct the automation routines and additional libraries for the additional features covered by this automated test script. WORKDIR /usr/src COPY requirements.txt . RUN pip install --upgrade pip RUN pip install -r requirements.txt requirements.txt selenium == 3.141 . 0 pytesseract == 0.3 . 6 Pillow == 8.0 . 1 numpy == 1.19 . 4 Faker == 4.14 . 2 fake - useragent == 0.1 . 11 pychalk == 2.0 . 1 mkdocs - material == 6.1 . 5 behave == 1.2 . 6","title":"Python Libs"},{"location":"setup/#runtime","text":"The container uses a volume at the root of the file system, to pass scripts to be executed inside of the container in the path /scripts . It is expected that when running the container a volume from the external host system, is mapped to this volume for execution. The expected default script for running the suite is main.py . # Location of Automated Test Scripts VOLUME /scripts CMD [ \"python\" , \"/scripts/main.py\" ] Now we are ready to run the container and with it, the automated test script that covers the technical challenge. Please go ahead to the Run section by navigating in the footer of this page...","title":"Runtime"}]}